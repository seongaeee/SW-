### bj_20058_마법사 상어와 파이어스톰

- 1.시계방향 돌리기: 배열 복사 후 다시 넣기
- 2.얼음 녹이기: ArrayList에 보관 후 한꺼번에 녹이기
- 3.남은 얼음 개수
- 4.가장 큰 덩어리: bfs 사용, 0이 아니고 방문하지않으면 bfs 시작

```
package SW역량테스트;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Queue;
import java.util.StringTokenizer;

public class bj_20058_마법사상어와파이어스톰 {
	static int N, Q, Qlist[], map[][];
	static int[] dr= {-1,1,0,0};
	static int[] dc= {0,0,-1,1};
	static BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
	static StringTokenizer st;
	
	public static void main(String[] args) throws IOException {
		st=new StringTokenizer(br.readLine());
		N=Integer.parseInt(st.nextToken());
		Q=Integer.parseInt(st.nextToken()); //시전한 단계수
		Qlist=new int[Q]; //시전한 단계 리스트
		
		N=(int) Math.pow(2, N); //가로, 세로 길이
		map=new int[N][N];
		
		for (int i = 0; i < N; i++) {
			st=new StringTokenizer(br.readLine());
			for (int j = 0; j < N; j++) {
				map[i][j]=Integer.parseInt(st.nextToken());
			}
		}
		
		st=new StringTokenizer(br.readLine());
		for (int i = 0; i < Q; i++) {
			Qlist[i]=Integer.parseInt(st.nextToken());
		}
		
		process();
	}

	private static void process() {
		
		for (int q = 0; q < Q; q++) {
			
			int L=Qlist[q]; //단계
			
			//1.시계방향으로 돌리기
			turnMap(L);
			
			//2.얼음 녹이기
			melt();
			
		}
		
		//3.남은 얼음 개수
		int totalSum = sumIce();
		System.out.println(totalSum);
		
		//4.가장 큰 덩어리
		int bigSum = bigIce();
		System.out.println(bigSum);
		
	}

	private static int bigIce() {
		boolean[][] visit=new boolean[N][N];
		int max=0;
		
		for (int i = 0; i < N; i++) {
			for (int j = 0; j < N; j++) {
				
				if(map[i][j]==0) continue;
				
				if(!visit[i][j]) { //bfs
					int sum=0;
					Queue<int[]> q=new LinkedList<int[]>();
					q.add(new int[] {i,j});
					visit[i][j]=true;
					
					while(!q.isEmpty()) {
						int[] tmp=q.poll();
						sum++;
						
						for (int d = 0; d < 4; d++) {
							int r=tmp[0]+dr[d];
							int c=tmp[1]+dc[d];
							
							if(r<0 || c<0 || r>=N || c>=N || map[r][c]==0 || visit[r][c]) continue;
							q.add(new int[] {r,c});
							visit[r][c]=true;
						}
					}
					
					max=Math.max(max, sum);
				}
				
			}
		}
		
		return max;
	}

	private static int sumIce() {
		int sum=0;
		for (int i = 0; i < N; i++) {
			for (int j = 0; j < N; j++) {
				sum+=map[i][j];
			}
		}
		return sum;
	}

	private static void melt() {
		
		ArrayList<int[]> meltlist=new ArrayList<int[]>();
		
		for (int i = 0; i < N; i++) {
			for (int j = 0; j < N; j++) {
				
				if(map[i][j]==0) continue;
				
				int cnt=0;
				for (int d = 0; d < 4; d++) {
					int r=i+dr[d];
					int c=j+dc[d];
					
					if(r<0 || c<0 || r>=N || c>=N || map[r][c]==0) continue;
					else cnt++;
				}
				if(cnt<3) meltlist.add(new int[] {i,j});
			}
		}
		
		for (int i = 0; i < meltlist.size(); i++) {
			int[] tmp=meltlist.get(i);
			map[tmp[0]][tmp[1]]--;
		}
	}

	private static void turnMap(int L) {
		
		int Size=(int) Math.pow(2, L);
		
		for (int i = 0; i < N; i=i+Size) {
			for (int j = 0; j < N; j=j+Size) {
				int r=i, c=j;
				for (int size = Size; size>0; size=size-2) {
					turn(r,c,size);
					r++; c++;
				}
			}
		}
		
	}


	private static void turn(int startR, int startC, int size) {
		
		
		Queue<Integer> tmp=new LinkedList<Integer>(); 
		
		//기존 배열 데이터 복사
		int r=startR;
		int c=startC;
		
		for (; c < startC+size-1; c++) tmp.offer(map[r][c]); 
		for (; r < startR+size-1; r++) tmp.offer(map[r][c]);
		for (; c > startC; c--) tmp.offer(map[r][c]); 
		for (; r > startR; r--) tmp.offer(map[r][c]);
		
		//시계 방향으로 넣기
		c=startC+size-1;
		
		for (; r < startR+size-1; r++) map[r][c]=tmp.poll() ; 
		for (; c > startC; c--) map[r][c]=tmp.poll(); 
		for (; r > startR; r--) map[r][c]=tmp.poll();
		for (; c < startC+size-1; c++) map[r][c]=tmp.poll();
		
	}
	
	private static void print() {
		for (int i = 0; i < N; i++) {
			for (int j = 0; j < N; j++) {
				System.out.print(map[i][j]);
			}
			System.out.println();
		}
		System.out.println("-----------");
	}
}

```
